# Systemd Error's
| # | Typical message snippet (what you’ll see in `systemctl status`, the journal or the shell) | What it really means | Try it yourself | First things to check / quick fix |
|---|---|---|---|---|
| 1 | `Failed to start foo.service: Unit foo.service not found.` | The unit file isn’t loaded or doesn’t exist in any unit‑search path. :contentReference[oaicite:0]{index=0} | `systemctl start doesntexist.service` | • Is the `*.service` file under `/etc/systemd/system` or `/usr/lib/systemd/system`?<br>• `systemctl daemon-reload` after you create/modify it. |
| 2 | `○ foo.service Loaded: masked (Reason: Unit foo.service is masked.)` | Someone (or a package) symlinked the unit to `/dev/null`; systemd refuses to start it. :contentReference[oaicite:1]{index=1} | `sudo systemctl mask ssh.service && systemctl start ssh.service` | `systemctl unmask foo.service` then (re‑)enable or start. |
| 3 | `Main process exited, code=exited, status=1/FAILURE`<br>`foo.service: Failed with result 'exit-code'.` | The service **did run**, but its main process exited with a non‑zero exit status. The final “result” can be `exit-code`, `signal`, `timeout`, `core-dump`, etc. :contentReference[oaicite:2]{index=2} | Write a shell script that just `exit 1`; point `ExecStart=` at it. | • Inspect the real exit status (`status=X`).<br>• `journalctl -u foo.service -e` for stack‑trace/stdout.<br>• Make sure `Restart=` policy is appropriate. |
| 4 | `foo.service: Start request repeated too quickly. Start-limit-hit.` | The unit crashed/restarted more than **StartLimitBurst** times inside **StartLimitInterval** (default = 5 times/10 s). Systemd stops trying. :contentReference[oaicite:3]{index=3} | `Restart=always` plus a command that instantly exits 1. | • Fix the root crash first!<br>• Bump limits with `StartLimitBurst=` or `RestartSec=` if you really need frequent restarts. |
| 5 | `Dependency failed for /data`<br>`Job data.mount/start failed with result 'dependency'.` | Another unit this one *Requires=* (or a device it needs) failed, timed‑out or wasn’t present. :contentReference[oaicite:4]{index=4} | Add `Requires=doesnt.exist.service` to a test unit and start it. | • Look at the failing prerequisite (`systemctl status that.service`).<br>• Double‑check mount points, device names, `After=` / `Requires=` lines. |
| 6 | `Job foo.service/start timed out.`<br>`Start operation timed out.` | The unit didn’t hit the `Type=`‑specific “started” condition within `TimeoutStartSec=`. | In a test unit set `ExecStart=/bin/sleep 600` and `TimeoutStartSec=5`. | • Increase `TimeoutStartSec=` or use `Type=exec/simple/notify` correctly.<br>• Confirm the process really starts. |
| 7 | `Can't open PID file /run/foo.pid (yet?) after start: No such file or directory` | With `Type=forking`, systemd waits for the PID file; it never appeared. | Point `PIDFile=` at a bogus path. | • Make sure the daemon really creates the file *and* that the path is writable.<br>• Or switch to `Type=simple`. |
| 8 | `System has not been booted with systemd as init system (PID 1). Can't operate.` | You’re inside WSL, a Docker image, chroot, or an init that isn’t systemd. :contentReference[oaicite:5]{index=5} | Run `systemctl` inside an Alpine or Ubuntu Docker container. | • Use container‑native commands, or run an init‑system image (`--init`) or enable systemd in WSL (`/etc/wsl.conf`). |
| 9 | `Failed to connect to bus: Host is down` | D‑Bus or the systemd user/session bus isn’t running (often in minimal containers or rescue mode). | Stop `dbus` then run `systemctl --user`. | • Start the `dbus` service or avoid systemctl in that environment. |
|10 | `Unknown operation foo` or `foo.service: Service lacks both ExecStart= and ExecStop=` | CLI typo **or** unit‑file syntax/validation error. | `systemctl strt ssh` (misspelling). | • Check your command spelling.<br>• Validate unit files with `systemd-analyze verify *.service`. |
